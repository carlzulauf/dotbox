#!/usr/bin/env ruby

require "fileutils"
require "pathname"
require "optparse"
require "json"

DOTFILES_BASE_DIR = File.expand_path(
  File.join(File.dirname(__FILE__), "..", "home")
)
INSTALL_DIR = File.expand_path("~")
BACKUP_DIR = File.expand_path("~/.backup-dotfiles")

Change = Struct.new(:desc, :src, :dest, :action)

class InstallDotfiles < Struct.new(:options)
  def self.parse(argv)
    options = default_options
    OptionParser.new do |parser|
      parser.banner = "Usage: bin/install [options]"

      parser.on(
          "-d [DIRECTORY]",
          "--install-dir [DIRECTORY]",
          "Directory to use (if you don't want `#{options[:install_dir]}`).") do |dir|
        options[:install_dir] = File.expand_path(dir)
      end

      parser.on(
          "-b [DIRECTORY]",
          "--backup-dir [DIRECTORY]",
          "Directory to backup existing dotfiles to. Default: `#{options[:backup_dir]}`.") do |dir|
        options[:backup_dir] = File.expand_path(dir)
      end

      parser.on(
          "-p [DIRECTORY]",
          "--private-dir [DIRECTORY]",
          "Add private directory for installer to layer into `#{options[:install_dir]}`.") do |dir|
        options[:private_dirs] << dir
      end

      parser.on(
          "-s [DIRECTORY]",
          "--dots-dir [DIRECTORY]",
          "Directory with the base layer of dotfiles. Usually where most of them are. Default: `#{options[:dots_dir]}`.") do |dir|
        options[:dots_dir] = File.expand_path(dir)
      end
    end.parse(argv)
    new(options)
  end

  def self.default_options
    {
      dots_dir: DOTFILES_BASE_DIR,
      install_dir: INSTALL_DIR,
      backup_dir: BACKUP_DIR,
      private_dirs: [],
    }
  end

  def call
    changes = find_all_changes
    display_config(changes)
    confirm_install if changes.any?(&:action)
    apply_changes(changes)
  end

  private

  def ignored_files

  end

  def install_path
    Pathname.new(options[:install_dir])
  end

  def backup_path
    Pathname.new(options[:backup_dir])
  end

  def dots_path
    Pathname.new(options[:dots_dir])
  end

  def private_paths
    return default_private_paths if options[:private_dirs].empty?
    options[:private_dirs].map { |dir| Pathname.new(dir) }
  end

  def default_private_paths
    [
      dots_path.join("../../dotbox-private/home"),
      dots_path.join("../private"),
    ].select(&:exist?)
  end

  def search_paths
    [dots_path, *private_paths]
  end

  def find_all_changes
    changes = {}
    search_paths.flat_map do |src|
      next unless src.directory?
      find_changes(src, install_path).each do |change|
        # final change to `dest` wins
        changes[change.dest] = change
      end
    end
    # find all broken links then merge changes on top
    find_broken_symlinks(changes.keys).merge(changes).values
  end

  # recursive. modified depth first search.
  # completes current dir before descending.
  def find_changes(src, dest)
    directories = []
    changes = []
    src.children.each do |child|
      if child.directory?
        directories << child
      elsif child.file?
        changes << check_file(child, dest.join(child.basename))
      else
        raise "wat (not file or directory, but child): #{child.inspect}"
      end
    end
    changes + directories.flat_map do |dir|
      find_changes(dir, dest.join(dir.basename))
    end
  end

  # look for broken symlinks adjacent to the list of files
  def find_broken_symlinks(files)
    {}.tap do |found|
      files.map(&:parent).uniq.select(&:exist?).each do |dir|
        dir.children.select{ |f| f.symlink? && !f.exist? }.map do |broken_link|
          found[broken_link] = change("⊠", File.readlink(broken_link), broken_link) do
            puts "Removing broken symlink: `#{broken_link}`"
            broken_link.unlink
          end
        end
      end
    end
  end

  def apply_changes(changes)
    if changes.none?(&:action) # no changes
      puts "No changes to apply. Exiting."
      puts
      exit
    end
    puts "Applying changes..."
    puts
    changes.each do |c|
      if c.action
        print " * "
        c.action.()
      end
    end
    puts
  end

  def check_file(src, dest)
    create_symlink = -> do
      puts "Creating symlink to `#{src}` at `#{dest}`"
      mkpath(dest.parent)
      FileUtils.symlink(src, dest)
    end
    if dest.symlink?
      if dest.exist? && dest.realpath == src
        change("✓", src, dest) # do nothing
      else
        change("↺", src, dest) do
          puts "Updating symlink at `#{dest}` from target of `#{File.readlink(dest)}` to `#{src}`"
          FileUtils.symlink(src, dest, force: true)
        end
      end
    elsif dest.exist?
      change("⇄", src, dest) do
        backup_dest = backup_path.join(dest.relative_path_from(install_path))
        puts "Moving existing file #{dest} to #{backup_dest}"
        mkpath(backup_dest.parent)
        FileUtils.mv(dest, backup_dest)
        create_symlink.()
      end
    else
      change("⊕", src, dest, &create_symlink)
    end
  end

  def change(desc, src, dest, &action)
    Change.new(desc, src, dest, action)
  end

  def mkpath(path)
    path.mkpath unless path.exist?
  end

  def confirm_install
    print "Are you sure you want to apply these changes (Yes/[No])? "
    answer = gets.strip
    if answer !~ /^y(es)?$/i
      puts "Received a non-yes response: #{answer.inspect}"
      exit
    end
    separator
  end

  def display_config(changes)
    puts
    puts "dotbox dotfiles installer"
    puts
    separator
    puts "| config"
    separator
    puts
    puts " --install-dir #{install_path}"
    puts " --backup-dir #{backup_path}"
    puts " --dots-dir #{dots_path}"
    private_paths.each { |path| puts " --private-dir #{path}"}
    puts
    separator
    puts "| dotfile changes for `#{install_path}`"
    separator
    puts
    puts "⊕ - create symlink"
    puts "⇄ - overwrite existing file (after backup)"
    puts "↺ - update symlink"
    puts "⊠ - remove broken symlink"
    puts "✓ - no change"
    puts
    changes.each do |change|
      puts " #{change.desc} #{change.dest}"
      puts "   ⤷ #{change.src}" if change.src
      puts
    end
    separator
  end

  def separator
    puts "-" * 80
  end
end

InstallDotfiles.parse(ARGV).()